#!/usr/bin/env python

import imaplib
import smtplib
from email.parser import Parser
import argparse
import sh
import os
import logging
import sys
import time
import threading
import signal
import re
import ConfigParser

CONFIGNAME = "/etc/malipat.config"
PATCHNAME = "malipat.patch"
REPOSPATH = "/tmp/malipat/"

class pushd:
	_saved_dir = None
	def __enter__(self):
		self._saved_dir = os.getcwd()

	def __exit__(self, type, value, traceback):
		os.chdir(self._saved_dir)

class Tester(threading.Thread):
	def __init__(self, argv):
		threading.Thread.__init__(self)
		self._stop = threading.Event()

		desc = 'Automatically test new patches from the mailing list.'
		parser = argparse.ArgumentParser(description=desc)
		parser.add_argument('-u', '--user',
			help = "Imap username. I.e. user@gmail.com.")
		parser.add_argument('-p', '--passwd',
			help = "Imap password.")
		parser.add_argument('-r', '--repo',
			help = "Where to get repo.")
		parser.add_argument('-t', '--timeout', default = 5,
			help = "Timeout before checking the mail.")
		parser.add_argument('--prefix',
			help = "Prefix that is being added by a mailing list. I.e. [arch-dev-public].")
		parser.add_argument('--report-to',
			help = "Where to send fail-reports about patches.(reply to all by default)")
		parser.add_argument('-c', '--config', default = CONFIGNAME,
			help = "Path to malipat config file.")
		parser.add_argument('-s', '--signature',
			help = "Text to add at the end of report email.")
		parser.add_argument('-d', '--debug', default = False, action = 'store_true',
			help = "Debug output.")

		opts = vars(parser.parse_args(argv[1:]))

		if os.path.isfile(opts['config']):
			config = ConfigParser.ConfigParser()
			config.read(opts['config'])

			# Config has lower priority than cmdline.
			for opt in config.options('General'):
				val = config.get('General', opt)

				if opt == 'timeout':
					val = int(val)

				if opt == 'debug':
					if val == 'True':
						val = True
					else:
						val = False

				setattr(self, opt, val)

		for opt in opts:
			if opts[opt]:
				setattr(self, opt, opts[opt])

		# Check for essentials 
		if not self.user:
			raise Exception("User is not specified")

		if not self.passwd:
			raise Exception("Password is not specified.")

		if not self.repo:
			raise Exception("Repository is not specified.")

		if self.debug:
			level = logging.DEBUG
		else:
			level = logging.WARNING

		logging.basicConfig(level=level)
		self.logger = logging.getLogger("Tester_%s_%s"%(self.user, self.repo))
		logging.getLogger("sh").setLevel(logging.WARNING)

		self._patches = {}
		self._stderr = ""
		self._stdout = ""

	def _login(self):
		self.mail = imaplib.IMAP4_SSL('imap.gmail.com')
		self.logger.info('Login as %s', self.user)
		self.mail.login(self.user, self.passwd)
		self.mail.select()
		self.logger.info('Login successful')

	def _logout(self):
		self.mail.close()
		self.mail.logout()
		self.logger.info('Logout successful')

	def _repo_update(self):
		with pushd():
			os.chdir(self.repo)
			sh.git("pull")

	def _send_email(self, to, msg):
		smtp = smtplib.SMTP('smtp.gmail.com:587')
		smtp.starttls()
		smtp.login(self.user, self.passwd)
		smtp.sendmail(self.user, to, msg)
		smtp.quit()

	def _send_report(self, patch, addmsg):
		msg = ""
		msg += "From: Malipat <"+self.user+">\n"

		headers = Parser().parsestr(patch)

		to = ""
		if self.report_to:
			msg += "To: %s\n" % self.report_to
			to = self.report_to
		else:
			msg += "To: %s, %s\n" % (headers['to'], headers['from'])
			if headers['cc']:
				msg += "Cc: %s\n" % headers['cc']
			to = headers["from"]

		msg += "In-Reply-To: %s\n" % headers['message-id']
		msg += "Subject: Re: %s\n" % headers['subject']

		msg += addmsg
		msg += self.signature.decode('string_escape')

		self.logger.debug(msg)

		self._send_email(to, msg)

	def _clear_stderr(self):
		self._stderr = ""

	def _clear_stdout(self):
		self._stdout = ""

	def _capture_stderr(self, line):
		self._stderr += line

	def _capture_stdout(self, line):
		self._stdout += line

	def _repo_prepare(self):
		self._repo_update()

		if not os.path.exists(REPOSPATH):
			os.makedirs(REPOSPATH)

		os.chdir(REPOSPATH)

		reponame = os.path.basename(self.repo)

		if os.path.exists(reponame):
			sh.rm("-rf", reponame)

		sh.cp("-a", self.repo, reponame)

		os.chdir(reponame)

	def _apply_patch(self, patch):
		with open(PATCHNAME, "w+") as f:
			f.write(patch)

		self._clear_stdout()
		self._clear_stderr()
		sh.git("am", PATCHNAME, _out = self._capture_stdout, _err = self._capture_stderr)

	def _build_patch(self):
		self._clear_stdout()
		self._clear_stderr()
		sh.make("-j3", _out = self._capture_stdout, _err = self._capture_stderr)

	def _test_patch(self):
		self._clear_stdout()
		self._clear_stderr()
		sh.make("test", "-j3", _out = self._capture_stdout, _err = self._capture_stderr)

	def _test_patches(self):
		self.logger.debug(str(self._patches.keys()))

		for mid in self._patches.keys():
			self.logger.debug("Checking patch/patchset with message-id %s" % mid)

			full = True
			for n in self._patches[mid]:
				if not self._patches[mid][n]:
					self.logger.debug("Patch set lacks patch no %d" % n)
					full = False
					break

			if not full:
				continue

			with pushd():
				self._repo_prepare()

				for n in self._patches[mid]:
					if n == 0:
						continue

					patch = self._patches[mid][n]
					msg = ""

					try:
						self._apply_patch(patch)
						msg += "Patch applies successfully.\n"
					except:
						msg += "Patch fails to apply.\n"
						self._send_report(patch, msg)
						break
					finally:
						self.logger.debug(msg)

					try:
						self._build_patch()
						msg += "Patch builds successfully.\n"
					except:
						msg += "Patch fails to build.\n"
						self._send_report(patch, msg)
						break
					finally:
						self.logger.debug(msg)

					try:
						self._test_patch()
						msg += "Patch passes tests successfully.\n"
					except:
						msg += "Patch fails to pass tests.\n"
						self.logger.debug(self._stdout)
						self.logger.debug(self._stderr)
						self._send_report(patch, msg)
						break
					finally:
						self.logger.debug(msg)

					msg += "\nSUCCESS.\n"
					self._send_report(patch, msg)
					self.logger.debug(msg)

				self._patches.pop(mid)

	def _find_patches(self):
		result, data = self.mail.uid('search', None, "UnSeen")
		uids = data[0].split()

		self.logger.debug("Have %d new messages", len(uids))

		regex = '^(%s)?\s*\[PATCH\s*((\d+)/(\d+))?\]' % re.escape(self.prefix)
		self.logger.debug("regex: %s" % regex)

		p = re.compile(regex)
		for uid in uids:
			result, data = self.mail.uid('fetch', uid, '(RFC822)')
			text = data[0][1]

			headers = Parser().parsestr(text)

			self.logger.debug("Subject: %s." % headers['subject'])

			result = p.match(headers['subject'])
			if not result:
				self.logger.debug("Doesn't look like patch")
				continue

			patchset = True if result.group(2) else False
			if patchset:
				self.logger.debug("Patch set.")
			else:
				self.logger.debug("Single patch.")
			n = int(result.group(3)) if patchset else 1
			N = int(result.group(4)) if patchset else 1
			self.logger.debug("Patch no %d/%d" % (n,N))

			mid = None
			if n == 0 or not patchset:
				mid = headers['message-id']
			elif patchset:
				mid = headers['in-reply-to']
			self.logger.debug("Message-id: %s." % mid)

			if mid not in self._patches:
				self._patches[mid] = {}

				if patchset:
					for i in xrange(N + 1):
						self._patches[mid][i] = None

			self._patches[mid][n] = text

	def run(self):
		while not self._stopped():
			self._login()
			self._find_patches()
			self._test_patches()
			self._logout()
			time.sleep(self.timeout)

	def stop(self):
		self._stop.set()

	def _stopped(self):
		return self._stop.is_set()

if __name__ == "__main__":
	t = Tester(sys.argv)

	def signal_handler(signal, frame):
		print("Stopping malipat...")
		t.stop()
		t.join()
		sys.exit(0)
	signal.signal(signal.SIGINT, signal_handler)
	signal.signal(signal.SIGTERM, signal_handler)

	t.daemon = True
	t.start()
	signal.pause()
	t.join()
